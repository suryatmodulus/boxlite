#![cfg(target_os = "linux")]
//! Container service implementation.
//!
//! Handles OCI container lifecycle (Init RPC).

use crate::service::server::GuestServer;
use boxlite_shared::{
    container_init_response, Container as ContainerService, ContainerInitError,
    ContainerInitRequest, ContainerInitResponse, ContainerInitSuccess,
};
use nix::mount::{mount, MsFlags};
use tonic::{Request, Response, Status};
use tracing::{debug, error, info};

use crate::container::Container;

#[tonic::async_trait]
impl ContainerService for GuestServer {
    async fn init(
        &self,
        request: Request<ContainerInitRequest>,
    ) -> Result<Response<ContainerInitResponse>, Status> {
        let init_req = request.into_inner();
        info!("Received container init request");

        // Get container ID from request (generated by host)
        let container_id = init_req.container_id.clone();
        if container_id.is_empty() {
            error!("Missing container_id in Init request");
            return Ok(Response::new(ContainerInitResponse {
                result: Some(container_init_response::Result::Error(ContainerInitError {
                    reason: "Missing container_id in Init request".to_string(),
                })),
            }));
        }

        // Check if guest is initialized
        {
            let init_state = self.init_state.lock().await;
            if !init_state.initialized {
                error!("Guest not initialized (Guest.Init must be called first)");
                return Ok(Response::new(ContainerInitResponse {
                    result: Some(container_init_response::Result::Error(ContainerInitError {
                        reason: "Guest not initialized (Guest.Init must be called first)"
                            .to_string(),
                    })),
                }));
            }
        }

        // Extract container config
        let config = init_req
            .container_config
            .ok_or_else(|| Status::invalid_argument("Missing container_config in Init request"))?;

        // Validate configuration
        if config.entrypoint.is_empty() {
            error!("Invalid container config: entrypoint cannot be empty");
            return Ok(Response::new(ContainerInitResponse {
                result: Some(container_init_response::Result::Error(ContainerInitError {
                    reason: "Invalid container config: entrypoint cannot be empty".to_string(),
                })),
            }));
        }

        info!("ðŸš€ Starting OCI container with received configuration");

        // Compute rootfs paths from container_id
        // Shared rootfs: /run/boxlite/shared/containers/{cid}/rootfs (overlayfs mount)
        // Bundle rootfs: /run/boxlite/containers/{cid}/rootfs (OCI bundle)
        let shared_rootfs = self.layout.shared().container(&container_id).rootfs_dir();
        let bundle_rootfs = self
            .layout
            .container_bundle_dir(&container_id)
            .join("rootfs");

        // Create bundle rootfs directory
        if let Err(e) = std::fs::create_dir_all(&bundle_rootfs) {
            error!("Failed to create bundle rootfs directory: {}", e);
            return Ok(Response::new(ContainerInitResponse {
                result: Some(container_init_response::Result::Error(ContainerInitError {
                    reason: format!("Failed to create bundle rootfs directory: {}", e),
                })),
            }));
        }

        // Bind mount shared rootfs to bundle rootfs
        if let Err(e) = mount(
            Some(shared_rootfs.as_path()),
            &bundle_rootfs,
            None::<&str>,
            MsFlags::MS_BIND,
            None::<&str>,
        ) {
            error!("Failed to bind mount rootfs: {}", e);
            return Ok(Response::new(ContainerInitResponse {
                result: Some(container_init_response::Result::Error(ContainerInitError {
                    reason: format!("Failed to bind mount rootfs: {}", e),
                })),
            }));
        }

        debug!(
            entrypoint = ?config.entrypoint,
            workdir = %config.workdir,
            env_count = config.env.len(),
            shared_rootfs = %shared_rootfs.display(),
            bundle_rootfs = %bundle_rootfs.display(),
            container_id = %container_id,
            "Container configuration"
        );

        // Start container using OCI bundle rootfs
        match Container::start(
            &container_id,
            &bundle_rootfs,
            config.entrypoint,
            config.env,
            &config.workdir,
        ) {
            Ok(container) => {
                // Verify container init process is running
                if !container.is_running() {
                    // Gather diagnostic information
                    let diagnostics = container.diagnose_exit();

                    error!(
                        "Container init process exited immediately after start. Diagnostics: {}",
                        diagnostics
                    );

                    return Ok(Response::new(ContainerInitResponse {
                        result: Some(container_init_response::Result::Error(ContainerInitError {
                            reason: format!(
                                "Container init process exited immediately. {}",
                                diagnostics
                            ),
                        })),
                    }));
                }

                info!(
                    container_id = %container_id,
                    "âœ… Container started successfully and ready for exec"
                );

                // Store container in registry
                self.containers.lock().await.insert(
                    container_id.clone(),
                    std::sync::Arc::new(tokio::sync::Mutex::new(container)),
                );

                Ok(Response::new(ContainerInitResponse {
                    result: Some(container_init_response::Result::Success(
                        ContainerInitSuccess { container_id },
                    )),
                }))
            }
            Err(e) => {
                error!("Failed to start container: {}", e);
                Ok(Response::new(ContainerInitResponse {
                    result: Some(container_init_response::Result::Error(ContainerInitError {
                        reason: format!("Failed to start container: {}", e),
                    })),
                }))
            }
        }
    }
}
